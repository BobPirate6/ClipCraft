package com.example.clipcraft.components

import androidx.compose.animation.core.animateDpAsState
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.scaleIn
import androidx.compose.animation.scaleOut
import androidx.compose.animation.expandHorizontally
import androidx.compose.animation.shrinkHorizontally
import androidx.compose.foundation.*
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.gestures.awaitEachGesture
import androidx.compose.foundation.gestures.awaitFirstDown
import androidx.compose.foundation.gestures.waitForUpOrCancellation
import androidx.compose.foundation.gestures.drag
import androidx.compose.foundation.gestures.awaitPointerSlopOrCancellation
import androidx.compose.ui.input.pointer.AwaitPointerEventScope
import androidx.compose.ui.input.pointer.util.VelocityTracker
import androidx.compose.ui.input.pointer.consumeAllChanges
import androidx.compose.ui.input.pointer.PointerEventPass
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import androidx.compose.ui.input.pointer.consume
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.input.pointer.PointerEvent
import androidx.compose.ui.input.pointer.PointerInputChange
import androidx.compose.ui.input.pointer.positionChanged
import androidx.compose.ui.input.pointer.changedToUp
import androidx.compose.ui.input.pointer.changedToDown
import androidx.compose.ui.input.pointer.isOutOfBounds
import androidx.compose.foundation.layout.*
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.horizontalScroll
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.DragHandle
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.runtime.mutableStateOf
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.layout.onGloballyPositioned
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import coil.compose.AsyncImage
import com.example.clipcraft.models.VideoSegment
import kotlinx.coroutines.launch
import kotlin.math.abs
import kotlin.math.roundToInt

/**
 * Современный видео таймлайн с поддержкой:
 * - Drag and drop для изменения порядка
 * - Изменение размера сегментов
 * - Добавление и удаление сегментов
 * - Плавная анимация
 * - Предпросмотр
 */
// Единая константа для всех преобразований
private const val PIXELS_PER_SECOND = 100f

// Типы жестов
private enum class GestureType {
    NONE,
    PINCH_ZOOM,
    TRIM_LEFT,
    TRIM_RIGHT,
    DRAG_SEGMENT,
    SCROLL_TIMELINE,
    TAP
}

// Состояние для отслеживания активных жестов
private data class GestureState(
    val type: GestureType = GestureType.NONE,
    val startOffset: Offset = Offset.Zero,
    val activePointers: Int = 0,
    val targetSegmentId: String? = null,
    val initialZoom: Float = 1f
)

@Composable
fun VideoTimeline(
    segments: List<VideoSegment>,
    currentPosition: Float,
    isPlaying: Boolean,
    zoomLevel: Float,
    modifier: Modifier = Modifier,
    onSegmentClick: (VideoSegment) -> Unit = {},
    onSegmentDelete: (String) -> Unit = {},
    onSegmentReorder: (Int, Int) -> Unit = { _, _ -> },
    onSegmentTrim: (String, Float, Boolean) -> Unit = { _, _, _ -> },
    onPositionChange: (Float) -> Unit = {},
    onZoomChange: (Float) -> Unit = {},
    selectedSegmentId: String? = null
) {
    android.util.Log.d("VideoTimeline", "Rendering with ${segments.size} segments, zoom=$zoomLevel")
    val density = LocalDensity.current
    val lazyListState = rememberLazyListState()
    val coroutineScope = rememberCoroutineScope()
    
    // Calculate timeline width for proper scaling
    var timelineWidthPx by remember { mutableStateOf(0f) }
    val timelineWidthDp = with(density) { timelineWidthPx.toDp() }
    
    // Состояние для drag and drop
    var draggedSegment by remember { mutableStateOf<VideoSegment?>(null) }
    var draggedFromIndex by remember { mutableStateOf(-1) }
    var dragOffset by remember { mutableStateOf(Offset.Zero) }
    var dropTargetIndex by remember { mutableStateOf(-1) }
    var currentDragOffset by remember { mutableStateOf(Offset.Zero) }
    
    // Состояние для триммирования
    var trimOffsets by remember { mutableStateOf(mutableMapOf<String, Pair<Float, Float>>()) }
    
    // Состояние для pinch-to-zoom
    var currentZoom by remember { mutableStateOf(zoomLevel) }
    
    // Состояние для отслеживания жестов
    var activeGesture by remember { mutableStateOf<GestureType?>(null) }
    var pointerCount by remember { mutableStateOf(0) }
    
    // Фиксированные лимиты зума без привязки к ширине таймлайна
    val minZoom = 0.5f  // 50% от базового размера
    val maxZoom = 5.0f  // 500% от базового размера
    
    // Обновляем текущий зум при изменении внешнего значения
    LaunchedEffect(zoomLevel) {
        currentZoom = zoomLevel
    }
    
    // Состояние жестов
    var gestureState by remember { mutableStateOf(GestureState()) }
    var pinchCenter by remember { mutableStateOf(Offset.Zero) }
    
    // Линейка времени сверху - закомментирована по запросу пользователя
    val totalDuration = segments.sumOf { it.duration.toDouble() }.toFloat()
    android.util.Log.d("VideoTimeline", "Total duration: $totalDuration")
    
    Box(
        modifier = modifier
            .fillMaxWidth()
            .height(120.dp)
            .background(Color.Black.copy(alpha = 0.9f))
            .clip(RoundedCornerShape(8.dp))
            .onGloballyPositioned { coordinates ->
                timelineWidthPx = coordinates.size.width.toFloat()
            }
            .pointerInput(segments, currentZoom, selectedSegmentId) {
                coroutineScope {
                    // Обработчик pinch zoom
                    launch {
                        detectTransformGestures(
                            onGesture = { _, _, zoom, _ ->
                                android.util.Log.d("VideoTimeline", "Pinch zoom: $currentZoom * $zoom")
                                val newZoom = (currentZoom * zoom).coerceIn(minZoom, maxZoom)
                                currentZoom = newZoom
                                onZoomChange(newZoom)
                                gestureState = gestureState.copy(type = GestureType.PINCH_ZOOM)
                            }
                        )
                    }
                    
                    // Обработчик tap и drag
                    launch {
                        detectDragGestures(
                            onDragStart = { offset ->
                                val targetSegment = findSegmentAtPosition(offset, segments, density, currentZoom, totalDuration, timelineWidthDp, selectedSegmentId)
                                
                                when {
                                    targetSegment == null -> {
                                        // Не потребляем, даем LazyRow скроллить
                                        gestureState = gestureState.copy(type = GestureType.SCROLL_TIMELINE)
                                    }
                                    !targetSegment.isSelected -> {
                                        // Невыделенный сегмент - скроллим
                                        gestureState = gestureState.copy(type = GestureType.SCROLL_TIMELINE)
                                    }
                                    else -> {
                                        val relativeX = offset.x - targetSegment.offset
                                        when {
                                            relativeX < 48.dp.toPx() -> {
                                                gestureState = gestureState.copy(
                                                    type = GestureType.TRIM_LEFT,
                                                    targetSegmentId = targetSegment.id
                                                )
                                                activeGesture = GestureType.TRIM_LEFT
                                            }
                                            relativeX > targetSegment.width - 48.dp.toPx() -> {
                                                gestureState = gestureState.copy(
                                                    type = GestureType.TRIM_RIGHT,
                                                    targetSegmentId = targetSegment.id
                                                )
                                                activeGesture = GestureType.TRIM_RIGHT
                                            }
                                            else -> {
                                                gestureState = gestureState.copy(
                                                    type = GestureType.DRAG_SEGMENT,
                                                    targetSegmentId = targetSegment.id
                                                )
                                                activeGesture = GestureType.DRAG_SEGMENT
                                                draggedSegment = targetSegment.segment
                                                draggedFromIndex = targetSegment.index
                                            }
                                        }
                                    }
                                }
                            },
                            onDrag = { _, dragAmount ->
                                when (gestureState.type) {
                                    GestureType.DRAG_SEGMENT -> {
                                        currentDragOffset += dragAmount
                                        
                                        // Определяем drop target
                                        gestureState.targetSegmentId?.let { id ->
                                            val segIndex = segments.indexOfFirst { it.id == id }
                                            if (segIndex != -1) {
                                                val segmentWidthPx = with(density) {
                                                    (segments[segIndex].duration * PIXELS_PER_SECOND * currentZoom).dp.toPx()
                                                }
                                                val thresholdPx = maxOf(40.dp.toPx(), segmentWidthPx / 3f)
                                                
                                                var targetIndex = segIndex
                                                if (currentDragOffset.x < -thresholdPx && segIndex > 0) {
                                                    targetIndex = segIndex - 1
                                                } else if (currentDragOffset.x > thresholdPx && segIndex < segments.size - 1) {
                                                    targetIndex = segIndex + 1
                                                }
                                                
                                                dropTargetIndex = targetIndex
                                            }
                                        }
                                    }
                                    GestureType.TRIM_LEFT -> {
                                        gestureState.targetSegmentId?.let { id ->
                                            val segment = segments.find { it.id == id }
                                            segment?.let { seg ->
                                                val currentTrimOffset = trimOffsets[id]?.first ?: 0f
                                                val newOffset = currentTrimOffset + dragAmount.x
                                                
                                                val maxLeftExpansion = -seg.startTime * PIXELS_PER_SECOND * currentZoom
                                                val maxRightMovement = (seg.duration - 0.5f) * PIXELS_PER_SECOND * currentZoom
                                                
                                                val clampedOffset = newOffset.coerceIn(maxLeftExpansion, maxRightMovement)
                                                trimOffsets[id] = (clampedOffset to (trimOffsets[id]?.second ?: 0f))
                                            }
                                        }
                                    }
                                    GestureType.TRIM_RIGHT -> {
                                        gestureState.targetSegmentId?.let { id ->
                                            val segment = segments.find { it.id == id }
                                            segment?.let { seg ->
                                                val currentTrimOffset = trimOffsets[id]?.second ?: 0f
                                                val newOffset = currentTrimOffset + dragAmount.x
                                                
                                                val availableExpansionRight = seg.originalDuration - seg.endTime
                                                val maxRightExpansion = availableExpansionRight * PIXELS_PER_SECOND * currentZoom
                                                val maxLeftMovement = -(seg.duration - 0.5f) * PIXELS_PER_SECOND * currentZoom
                                                
                                                val clampedOffset = newOffset.coerceIn(maxLeftMovement, maxRightExpansion)
                                                trimOffsets[id] = ((trimOffsets[id]?.first ?: 0f) to clampedOffset)
                                            }
                                        }
                                    }
                                    else -> {}
                                }
                            },
                            onDragEnd = {
                                when (gestureState.type) {
                                    GestureType.DRAG_SEGMENT -> {
                                        if (dropTargetIndex != -1 && dropTargetIndex != draggedFromIndex) {
                                            onSegmentReorder(draggedFromIndex, dropTargetIndex)
                                        }
                                        draggedSegment = null
                                        draggedFromIndex = -1
                                        currentDragOffset = Offset.Zero
                                        dropTargetIndex = -1
                                    }
                                    GestureType.TRIM_LEFT -> {
                                        gestureState.targetSegmentId?.let { id ->
                                            trimOffsets[id]?.first?.let { offset ->
                                                val deltaTime = offset / (PIXELS_PER_SECOND * currentZoom)
                                                onSegmentTrim(id, deltaTime, true)
                                            }
                                            trimOffsets.remove(id)
                                        }
                                    }
                                    GestureType.TRIM_RIGHT -> {
                                        gestureState.targetSegmentId?.let { id ->
                                            trimOffsets[id]?.second?.let { offset ->
                                                val deltaTime = offset / (PIXELS_PER_SECOND * currentZoom)
                                                onSegmentTrim(id, deltaTime, false)
                                            }
                                            trimOffsets.remove(id)
                                        }
                                    }
                                    else -> {}
                                }
                                
                                gestureState = GestureState()
                                activeGesture = GestureType.NONE
                            }
                        )
                    }
                    
                    // Обработчик tap
                    launch {
                        detectTapGestures(
                            onTap = { offset ->
                                val targetSegment = findSegmentAtPosition(offset, segments, density, currentZoom, totalDuration, timelineWidthDp, selectedSegmentId)
                                if (targetSegment != null) {
                                    onSegmentClick(targetSegment.segment)
                                }
                            }
                        )
                    }
                }
            }
    ) {
        // TimeRuler убрана - белые риски больше не показываются
        /*
        TimeRuler(
            totalDuration = totalDuration,
            zoomLevel = zoomLevel,
            modifier = Modifier
                .fillMaxWidth()
                .height(30.dp)
                .align(Alignment.TopCenter)
        )
        */
        
        
        // Основной контент таймлайна
        LazyRow(
            state = lazyListState,
            modifier = Modifier
                .fillMaxWidth()
                .fillMaxHeight(),
            horizontalArrangement = Arrangement.spacedBy(2.dp),
            contentPadding = PaddingValues(horizontal = 16.dp),
            verticalAlignment = Alignment.CenterVertically,
            userScrollEnabled = true
        ) {
            itemsIndexed(
                items = segments,
                key = { _, segment -> segment.id }
            ) { index, segment ->
                VideoSegmentItem(
                    segment = segment,
                    index = index,
                    isSelected = segment.id == selectedSegmentId,
                    isDragging = segment.id == gestureState.targetSegmentId && gestureState.type == GestureType.DRAG_SEGMENT,
                    isDropTarget = index == dropTargetIndex,
                    zoomLevel = zoomLevel,
                    totalDuration = totalDuration,
                    timelineWidthDp = timelineWidthDp,
                    dragOffset = if (segment.id == gestureState.targetSegmentId && gestureState.type == GestureType.DRAG_SEGMENT) currentDragOffset else Offset.Zero,
                    activeGesture = if (segment.id == gestureState.targetSegmentId) gestureState.type else GestureType.NONE,
                    leftTrimOffset = trimOffsets[segment.id]?.first ?: 0f,
                    rightTrimOffset = trimOffsets[segment.id]?.second ?: 0f,
                    onActiveGestureChange = { /* Обрабатывается в едином GestureDetector */ },
                    onSegmentClick = { /* Обрабатывается в GestureDetector */ },
                    onSegmentDelete = { onSegmentDelete(segment.id) },
                    onDragStart = { /* Обрабатывается в GestureDetector */ },
                    onDrag = { offset ->
                        if (gestureState.type == GestureType.DRAG_SEGMENT && segment.id == gestureState.targetSegmentId) {
                            currentDragOffset = offset
                        }
                    },
                    onDragEnd = { /* Обрабатывается в GestureDetector */ },
                    onTrimStart = { delta ->
                        if (gestureState.type == GestureType.TRIM_LEFT && segment.id == gestureState.targetSegmentId) {
                            onSegmentTrim(segment.id, delta, true)
                        }
                    },
                    onTrimEnd = { delta ->
                        if (gestureState.type == GestureType.TRIM_RIGHT && segment.id == gestureState.targetSegmentId) {
                            onSegmentTrim(segment.id, delta, false)
                        }
                    }
                )
            }
        }
        
        // Маркер времени убран из таймлайна редактора
    }
}

/**
 * Компонент отдельного сегмента видео
 */
@Composable
private fun VideoSegmentItem(
    segment: VideoSegment,
    index: Int,
    isSelected: Boolean,
    isDragging: Boolean,
    isDropTarget: Boolean,
    zoomLevel: Float,
    totalDuration: Float,
    timelineWidthDp: androidx.compose.ui.unit.Dp,
    dragOffset: Offset = Offset.Zero,
    activeGesture: GestureType?,
    leftTrimOffset: Float = 0f,
    rightTrimOffset: Float = 0f,
    onActiveGestureChange: (GestureType?) -> Unit,
    onSegmentClick: () -> Unit,
    onSegmentDelete: () -> Unit,
    onDragStart: () -> Unit,
    onDrag: (Offset) -> Unit,
    onDragEnd: () -> Unit,
    onTrimStart: (Float) -> Unit,
    onTrimEnd: (Float) -> Unit
) {
    val density = LocalDensity.current
    var segmentWidth by remember { mutableStateOf(0f) }
    
    // Анимация для выделения и перетаскивания
    val elevation by animateDpAsState(
        targetValue = when {
            isDragging -> 16.dp
            isSelected -> 8.dp
            else -> 2.dp
        },
        label = "elevation"
    )
    
    val scale by animateFloatAsState(
        targetValue = when {
            isDragging -> 1.1f
            isDropTarget -> 0.95f
            else -> 1f
        },
        label = "scale"
    )
    
    // Текущая и максимальная длительность
    val currentDuration = segment.duration
    val maxDuration = segment.originalDuration
    val availableExpansionLeft = segment.startTime
    val availableExpansionRight = maxDuration - segment.endTime
    
    // Вычисляем ширину с учетом временного изменения
    val visualDuration = currentDuration + (rightTrimOffset - leftTrimOffset) / (PIXELS_PER_SECOND * zoomLevel)
    
    val baseWidthPx = visualDuration * PIXELS_PER_SECOND * zoomLevel
    val calculatedWidth = with(density) { baseWidthPx.toDp() }
    
    Box(
        modifier = Modifier
            .width(calculatedWidth)
            .height(80.dp)
    ) {
        // Визуальный индикатор drop target
        AnimatedVisibility(
            visible = isDropTarget && !isDragging,
            enter = fadeIn() + expandHorizontally(),
            exit = fadeOut() + shrinkHorizontally()
        ) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .clip(RoundedCornerShape(8.dp))
                    .background(
                        MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.3f)
                    )
                    .border(
                        width = 3.dp,
                        color = MaterialTheme.colorScheme.primary.copy(alpha = 0.8f),
                        shape = RoundedCornerShape(8.dp)
                    )
            )
        }
        
        Box(
            modifier = Modifier
                .fillMaxSize()
                .offset { IntOffset(dragOffset.x.roundToInt(), dragOffset.y.roundToInt()) }
                .shadow(elevation, RoundedCornerShape(8.dp))
                .clip(RoundedCornerShape(8.dp))
                .background(
                    MaterialTheme.colorScheme.surface
                )
                .border(
                    width = if (isSelected) 2.dp else 1.dp,
                    color = if (isSelected) MaterialTheme.colorScheme.primary 
                           else Color.White.copy(alpha = 0.3f),
                    shape = RoundedCornerShape(8.dp)
                )
                .graphicsLayer {
                    scaleX = scale
                    scaleY = scale
                    alpha = if (isDragging) 0.85f else 1f
                }
                .onGloballyPositioned { coordinates ->
                    segmentWidth = coordinates.size.width.toFloat()
                }
        ) {
                                            draggedFromIndex = targetSegment?.index ?: -1
                                        }
                                        GestureType.TRIM_LEFT -> {
                                            gestureState = gestureState.copy(
                                                type = GestureType.TRIM_LEFT,
                                                targetSegmentId = targetSegment?.id
                                            )
                                            activeGesture = GestureType.TRIM_LEFT
                                        }
                                        GestureType.TRIM_RIGHT -> {
                                            gestureState = gestureState.copy(
                                                type = GestureType.TRIM_RIGHT,
                                                targetSegmentId = targetSegment?.id
                                            )
                                            activeGesture = GestureType.TRIM_RIGHT
                                        }
                                        GestureType.SCROLL_TIMELINE -> {
                                            // Не потребляем события - пусть LazyRow скроллит
                                        }
                                        else -> {}
                                    }
                                }
                                
                                // Обрабатываем активные жесты
                                if (isDragging && finalGestureType != GestureType.SCROLL_TIMELINE) {
                                    val dragAmount = change.position - change.previousPosition
                                    
                                    when (finalGestureType) {
                                        GestureType.DRAG_SEGMENT -> {
                                            currentDragOffset = currentOffset + dragAmount
                                            currentOffset = currentDragOffset
                                            
                                            // Определяем drop target
                                            targetSegment?.let { seg ->
                                                val segmentWidthPx = seg.width
                                                val thresholdPx = maxOf(40.dp.toPx(), segmentWidthPx / 3f)
                                                
                                                var targetIndex = seg.index
                                                if (currentOffset.x < -thresholdPx && seg.index > 0) {
                                                    targetIndex = seg.index - 1
                                                } else if (currentOffset.x > thresholdPx && seg.index < segments.size - 1) {
                                                    targetIndex = seg.index + 1
                                                }
                                                
                                                dropTargetIndex = targetIndex
                                            }
                                        }
                                        GestureType.TRIM_LEFT -> {
                                            targetSegment?.let { seg ->
                                                val currentTrimOffset = trimOffsets[seg.id]?.first ?: 0f
                                                val newOffset = currentTrimOffset + dragAmount.x
                                                
                                                val maxLeftExpansion = -seg.segment.startTime * PIXELS_PER_SECOND * currentZoom
                                                val maxRightMovement = (seg.segment.duration - 0.5f) * PIXELS_PER_SECOND * currentZoom
                                                
                                                val clampedOffset = newOffset.coerceIn(maxLeftExpansion, maxRightMovement)
                                                trimOffsets[seg.id] = (clampedOffset to (trimOffsets[seg.id]?.second ?: 0f))
                                            }
                                        }
                                        GestureType.TRIM_RIGHT -> {
                                            targetSegment?.let { seg ->
                                                val currentTrimOffset = trimOffsets[seg.id]?.second ?: 0f
                                                val newOffset = currentTrimOffset + dragAmount.x
                                                
                                                val availableExpansionRight = seg.segment.originalDuration - seg.segment.endTime
                                                val maxRightExpansion = availableExpansionRight * PIXELS_PER_SECOND * currentZoom
                                                val maxLeftMovement = -(seg.segment.duration - 0.5f) * PIXELS_PER_SECOND * currentZoom
                                                
                                                val clampedOffset = newOffset.coerceIn(maxLeftMovement, maxRightExpansion)
                                                trimOffsets[seg.id] = ((trimOffsets[seg.id]?.first ?: 0f) to clampedOffset)
                                            }
                                        }
                                        else -> {}
                                    }
                                    
                                    change.consume()
                                }
                                
                                // Проверяем завершение жеста
                                if (change.changedToUp()) {
                                    // Обрабатываем tap
                                    if (!isDragging && targetSegment != null) {
                                        onSegmentClick(targetSegment.segment)
                                    }
                                    
                                    // Завершаем активные жесты
                                    when (finalGestureType) {
                                        GestureType.DRAG_SEGMENT -> {
                                            if (dropTargetIndex != -1 && dropTargetIndex != draggedFromIndex) {
                                                onSegmentReorder(draggedFromIndex, dropTargetIndex)
                                            }
                                            draggedSegment = null
                                            draggedFromIndex = -1
                                            currentDragOffset = Offset.Zero
                                            dropTargetIndex = -1
                                        }
                                        GestureType.TRIM_LEFT -> {
                                            targetSegment?.let { seg ->
                                                trimOffsets[seg.id]?.first?.let { offset ->
                                                    val deltaTime = offset / (PIXELS_PER_SECOND * currentZoom)
                                                    onSegmentTrim(seg.id, deltaTime, true)
                                                }
                                                trimOffsets.remove(seg.id)
                                            }
                                        }
                                        GestureType.TRIM_RIGHT -> {
                                            targetSegment?.let { seg ->
                                                trimOffsets[seg.id]?.second?.let { offset ->
                                                    val deltaTime = offset / (PIXELS_PER_SECOND * currentZoom)
                                                    onSegmentTrim(seg.id, deltaTime, false)
                                                }
                                                trimOffsets.remove(seg.id)
                                            }
                                        }
                                        else -> {}
                                    }
                                    
                                    // Сбрасываем состояние
                                    gestureState = GestureState()
                                    activeGesture = GestureType.NONE
                                    break
                                }
                            }
                        }
                    }
                }
            }
    ) {
        // TimeRuler убрана - белые риски больше не показываются
        /*
        TimeRuler(
            totalDuration = totalDuration,
            zoomLevel = zoomLevel,
            modifier = Modifier
                .fillMaxWidth()
                .height(30.dp)
                .align(Alignment.TopCenter)
        )
        */
        
        
        // Основной контент таймлайна
        LazyRow(
            state = lazyListState,
            modifier = Modifier
                .fillMaxWidth()
                .fillMaxHeight(),
            horizontalArrangement = Arrangement.spacedBy(2.dp),
            contentPadding = PaddingValues(horizontal = 16.dp),
            verticalAlignment = Alignment.CenterVertically,
            userScrollEnabled = true
        ) {
            itemsIndexed(
                items = segments,
                key = { _, segment -> segment.id }
            ) { index, segment ->
                VideoSegmentItem(
                    segment = segment,
                    index = index,
                    isSelected = segment.id == selectedSegmentId,
                    isDragging = segment.id == gestureState.targetSegmentId && gestureState.type == GestureType.DRAG_SEGMENT,
                    isDropTarget = index == dropTargetIndex,
                    zoomLevel = zoomLevel,
                    totalDuration = totalDuration,
                    timelineWidthDp = timelineWidthDp,
                    dragOffset = if (segment.id == gestureState.targetSegmentId && gestureState.type == GestureType.DRAG_SEGMENT) currentDragOffset else Offset.Zero,
                    activeGesture = if (segment.id == gestureState.targetSegmentId) gestureState.type else GestureType.NONE,
                    leftTrimOffset = trimOffsets[segment.id]?.first ?: 0f,
                    rightTrimOffset = trimOffsets[segment.id]?.second ?: 0f,
                    onActiveGestureChange = { /* Теперь обрабатывается в едином GestureDetector */ },
                    onSegmentClick = { /* Обрабатывается в GestureDetector */ },
                    onSegmentDelete = { onSegmentDelete(segment.id) },
                    onDragStart = { /* Обрабатывается в GestureDetector */ },
                    onDrag = { offset ->
                        if (gestureState.type == GestureType.DRAG_SEGMENT && segment.id == gestureState.targetSegmentId) {
                            currentDragOffset = offset
                            
                            // Вычисляем целевой индекс для переупорядочивания
                            val draggedCenterX = offset.x
                            val segmentWidthPx = with(density) {
                                (segment.duration * PIXELS_PER_SECOND * zoomLevel).dp.toPx()
                            }
                            
                            val thresholdPx = maxOf(
                                with(density) { 40.dp.toPx() },
                                segmentWidthPx / 3f
                            )
                            
                            var targetIndex = index
                            if (draggedCenterX < -thresholdPx && index > 0) {
                                targetIndex = index - 1
                            } else if (draggedCenterX > thresholdPx && index < segments.size - 1) {
                                targetIndex = index + 1
                            }
                            
                            if (targetIndex != dropTargetIndex) {
                                dropTargetIndex = targetIndex
                            }
                        }
                    },
                    onDragEnd = {
                        if (gestureState.type == GestureType.DRAG_SEGMENT && segment.id == gestureState.targetSegmentId) {
                            if (dropTargetIndex != -1 && dropTargetIndex != segments.indexOfFirst { it.id == gestureState.targetSegmentId }) {
                                onSegmentReorder(segments.indexOfFirst { it.id == gestureState.targetSegmentId }, dropTargetIndex)
                            }
                            currentDragOffset = Offset.Zero
                            dropTargetIndex = -1
                        }
                    },
                    onTrimStart = { delta ->
                        if (gestureState.type == GestureType.TRIM_LEFT && segment.id == gestureState.targetSegmentId) {
                            onSegmentTrim(segment.id, delta, true)
                        }
                    },
                    onTrimEnd = { delta ->
                        if (gestureState.type == GestureType.TRIM_RIGHT && segment.id == gestureState.targetSegmentId) {
                            onSegmentTrim(segment.id, delta, false)
                        }
                    }
                )
            }
        }
        
        // Маркер времени убран из таймлайна редактора
    }
}

/**
 * Компонент отдельного сегмента видео
 */
@Composable
private fun VideoSegmentItem(
    segment: VideoSegment,
    index: Int,
    isSelected: Boolean,
    isDragging: Boolean,
    isDropTarget: Boolean,
    zoomLevel: Float,
    totalDuration: Float,
    timelineWidthDp: androidx.compose.ui.unit.Dp,
    dragOffset: Offset = Offset.Zero,
    activeGesture: GestureType?,
    leftTrimOffset: Float = 0f,
    rightTrimOffset: Float = 0f,
    onActiveGestureChange: (GestureType?) -> Unit,
    onSegmentClick: () -> Unit,
    onSegmentDelete: () -> Unit,
    onDragStart: () -> Unit,
    onDrag: (Offset) -> Unit,
    onDragEnd: () -> Unit,
    onTrimStart: (Float) -> Unit,
    onTrimEnd: (Float) -> Unit
) {
    val density = LocalDensity.current
    var segmentWidth by remember { mutableStateOf(0f) }
    
    // Анимация для выделения и перетаскивания
    val elevation by animateDpAsState(
        targetValue = when {
            isDragging -> 16.dp
            isSelected -> 8.dp
            else -> 2.dp
        },
        label = "elevation"
    )
    
    val scale by animateFloatAsState(
        targetValue = when {
            isDragging -> 1.1f
            isDropTarget -> 0.95f
            else -> 1f
        },
        label = "scale"
    )
    
    // Локальные переменные для анимации (теперь офсеты передаются сверху)
    
    // Текущая и максимальная длительность
    val currentDuration = segment.duration
    val maxDuration = segment.originalDuration
    val availableExpansionLeft = segment.startTime // Сколько можно расширить влево
    val availableExpansionRight = maxDuration - segment.endTime // Сколько можно расширить вправо
    
    // Вычисляем ширину с учетом временного изменения
    val visualDuration = currentDuration + (rightTrimOffset - leftTrimOffset) / (PIXELS_PER_SECOND * zoomLevel)
    
    // Use fixed pixels per second instead of fitting to timeline width
    // This prevents automatic scaling and allows proper pinch-to-zoom
    val baseWidthPx = visualDuration * PIXELS_PER_SECOND * zoomLevel
    val calculatedWidth = with(density) { baseWidthPx.toDp() }
    
    Box(
        modifier = Modifier
            .width(calculatedWidth)
            .height(80.dp)
    ) {
        // Визуальный индикатор drop target
        AnimatedVisibility(
            visible = isDropTarget && !isDragging,
            enter = fadeIn() + expandHorizontally(),
            exit = fadeOut() + shrinkHorizontally()
        ) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .clip(RoundedCornerShape(8.dp))
                    .background(
                        MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.3f)
                    )
                    .border(
                        width = 3.dp,
                        color = MaterialTheme.colorScheme.primary.copy(alpha = 0.8f),
                        shape = RoundedCornerShape(8.dp)
                    )
            )
        }
        
        Box(
            modifier = Modifier
                .fillMaxSize()
                .offset { IntOffset(dragOffset.x.roundToInt(), dragOffset.y.roundToInt()) }
                .shadow(elevation, RoundedCornerShape(8.dp))
                .clip(RoundedCornerShape(8.dp))
                .background(
                    MaterialTheme.colorScheme.surface
                )
                .border(
                    width = if (isSelected) 2.dp else 1.dp,
                    color = if (isSelected) MaterialTheme.colorScheme.primary 
                           else Color.White.copy(alpha = 0.3f),
                    shape = RoundedCornerShape(8.dp)
                )
                .graphicsLayer {
                    scaleX = scale
                    scaleY = scale
                    alpha = if (isDragging) 1f else 1f
                    if (isDragging) {
                        // Делаем перетаскиваемый клип ярче
                        // Используем альтернативный подход для эффекта яркости
                        alpha = 0.85f
                    }
                }
                .onGloballyPositioned { coordinates ->
                    segmentWidth = coordinates.size.width.toFloat()
                }
        ) {
        // Превью видео с учетом обрезки
        Box(modifier = Modifier.fillMaxSize()) {
            segment.thumbnails.firstOrNull()?.let { thumbnail ->
                AsyncImage(
                    model = thumbnail,
                    contentDescription = null,
                    modifier = Modifier.fillMaxSize(),
                    contentScale = ContentScale.Crop,
                    alpha = 0.7f
                )
            }
            
            // Убираем визуальные маски - теперь сегмент реально изменяет размер
        }
        
        // Эффект яркости при перетаскивании
        if (isDragging) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .background(Color.White.copy(alpha = 0.2f))
            )
        }
        
        // Полупрозрачная версия для места назначения
        if (isDropTarget && isDragging) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .background(Color.White.copy(alpha = 0.1f))
            )
        }
        
        // Кнопка удаления (только для выделенного)
        if (isSelected) {
            IconButton(
                onClick = onSegmentDelete,
                modifier = Modifier
                    .align(Alignment.TopEnd)
                    .size(24.dp)
                    .clip(CircleShape)
                    .background(Color.Red.copy(alpha = 0.7f))
            ) {
                Icon(
                    Icons.Default.Close,
                    contentDescription = "Удалить",
                    tint = Color.White,
                    modifier = Modifier.size(16.dp)
                )
            }
        }
        
        // Длительность сегмента
        Text(
            text = "${segment.duration.roundToInt()}s",
            color = Color.White,
            fontSize = 12.sp,
            modifier = Modifier
                .align(Alignment.BottomStart)
                .padding(8.dp)
                .background(
                    Color.Black.copy(alpha = 0.5f),
                    RoundedCornerShape(4.dp)
                )
                .padding(horizontal = 6.dp, vertical = 2.dp)
        )
        
        // Кнопка перетаскивания по центру (только для выделенного)
        if (isSelected) {
            val isDragging = activeGesture == GestureType.DRAG_SEGMENT
            
            Box(
                modifier = Modifier
                    .align(Alignment.Center)
                    .size(60.dp),  // Увеличенная зона касания
                contentAlignment = Alignment.Center
            ) {
                AnimatedVisibility(
                    visible = true,
                    enter = fadeIn() + scaleIn(),
                    exit = fadeOut() + scaleOut()
                ) {
                    Box(
                        modifier = Modifier
                            .size(40.dp)
                            .clip(CircleShape)
                            .background(
                                if (isDragging)
                                    MaterialTheme.colorScheme.primary
                                else 
                                    Color.Black.copy(alpha = 0.6f)
                            )
                            .border(
                                width = 2.dp,
                                color = if (isDragging) Color.White else Color.White.copy(alpha = 0.5f),
                                shape = CircleShape
                            ),
                        contentAlignment = Alignment.Center
                    ) {
                        Icon(
                            Icons.Default.DragHandle,
                            contentDescription = "Перетащить",
                            modifier = Modifier.size(24.dp),
                            tint = Color.White
                        )
                    }
                }
            }
        }
        
        // Невидимые зоны для изменения размера (только для выделенного сегмента)
        if (isSelected) {
            // Состояние для визуальной обратной связи
            val isTrimmingLeft = activeGesture == GestureType.TRIM_LEFT
            val isTrimmingRight = activeGesture == GestureType.TRIM_RIGHT
            
            // Левая зона для изменения размера с увеличенной областью касания
            Box(
                modifier = Modifier
                    .align(Alignment.CenterStart)
                    .width(48.dp)  // Увеличенная зона касания
                    .fillMaxHeight()
                    .offset(x = with(density) { (leftTrimOffset - 8.dp.toPx()).toDp() })  // Смещаем зону влево для удобства
            )
            
            // Правая зона для изменения размера с увеличенной областью касания
            Box(
                modifier = Modifier
                    .align(Alignment.CenterEnd)
                    .width(48.dp)  // Увеличенная зона касания
                    .fillMaxHeight()
                    .offset(x = with(density) { (rightTrimOffset - 8.dp.toPx()).toDp() })  // Смещаем зону для удобства
            )
            
            // Визуальные индикаторы при триммировании (опциональные)
            if (isTrimmingLeft) {
                Box(
                    modifier = Modifier
                        .align(Alignment.CenterStart)
                        .width(4.dp)
                        .fillMaxHeight()
                        .offset(x = with(density) { leftTrimOffset.toDp() })
                        .background(MaterialTheme.colorScheme.primary)
                )
            }
            
            if (isTrimmingRight) {
                Box(
                    modifier = Modifier
                        .align(Alignment.CenterEnd)
                        .width(4.dp)
                        .fillMaxHeight()
                        .offset(x = with(density) { rightTrimOffset.toDp() })
                        .background(MaterialTheme.colorScheme.primary)
                )
            }
        }
    }
    }
}

/**
 * Ручка для изменения размера сегмента
 */
@Composable
private fun TrimHandle(
    isStart: Boolean,
    modifier: Modifier = Modifier,
    onDrag: (Float) -> Unit,
    onDragEnd: () -> Unit = {}
) {
    var isDragging by remember { mutableStateOf(false) }
    
    Box(
        modifier = modifier
            .width(32.dp)  // Увеличенная зона касания
            .fillMaxHeight()
            .pointerInput(Unit) {
                detectDragGestures(
                    onDragStart = {
                        isDragging = true
                    },
                    onDrag = { _, dragAmount ->
                        // Передаем изменения в реальном времени
                        // Для обоих краев используем прямое значение dragAmount.x
                        onDrag(dragAmount.x)
                    },
                    onDragEnd = {
                        isDragging = false
                        onDragEnd()
                    }
                )
            }
    ) {
        // Визуальная часть ручки - делаем менее заметной
        Box(
            modifier = Modifier
                .width(12.dp)
                .fillMaxHeight()
                .align(if (isStart) Alignment.CenterStart else Alignment.CenterEnd)
                .background(
                    if (isDragging) Color.White.copy(alpha = 0.5f) 
                    else Color.White.copy(alpha = 0.3f),
                    if (isStart) RoundedCornerShape(topStart = 8.dp, bottomStart = 8.dp)
                    else RoundedCornerShape(topEnd = 8.dp, bottomEnd = 8.dp)
                )
        ) {
            // Визуальный индикатор - тонкая вертикальная линия
            Box(
                modifier = Modifier
                    .width(2.dp)
                    .fillMaxHeight()
                    .align(Alignment.Center)
                    .background(
                        if (isDragging) Color.White.copy(alpha = 0.7f)
                        else Color.White.copy(alpha = 0.4f)
                    )
            )
        }
    }
}

/**
 * Линейка времени
 */
@Composable
private fun TimeRuler(
    totalDuration: Float,
    zoomLevel: Float,
    modifier: Modifier = Modifier
) {
    val scrollState = rememberScrollState()
    val density = LocalDensity.current
    
    // Ширина линейки = totalDuration × PIXELS_PER_SECOND × zoomLevel
    val rulerWidthDp = with(density) {
        (totalDuration * PIXELS_PER_SECOND * zoomLevel).toDp()
    }
    
    Box(modifier = modifier) {
        Canvas(
            modifier = Modifier
                .width(rulerWidthDp)
                .fillMaxHeight()
                .horizontalScroll(scrollState)
        ) {
            val pixelsPerSecond = PIXELS_PER_SECOND * zoomLevel
            
            // Рисуем основную линию
            drawLine(
                color = Color.Gray,
                start = Offset(0f, size.height),
                end = Offset(size.width, size.height),
                strokeWidth = 1.dp.toPx()
            )
            
            // Определяем шаг меток в зависимости от зума
            val majorStep = when {
                zoomLevel < 0.5f -> 5.0f   // Major каждые 5 сек при малом зуме
                zoomLevel < 2.0f -> 1.0f   // Major каждую секунду при среднем зуме
                else -> 0.5f               // Major каждые 0.5 сек при большом зуме
            }
            val minorStep = majorStep / 5f // Minor метки в 5 раз чаще
            
            // Рисуем метки времени
            var currentTime = 0f
            while (currentTime <= totalDuration) {
                val x = currentTime * pixelsPerSecond
                
                val isMajor = (currentTime % majorStep) < 0.01f
                val isMinor = (currentTime % minorStep) < 0.01f
                
                if (isMajor || isMinor) {
                    drawLine(
                        color = Color.Gray,
                        start = Offset(x, size.height),
                        end = Offset(x, size.height - if (isMajor) 10.dp.toPx() else 5.dp.toPx()),
                        strokeWidth = if (isMajor) 1.5f.dp.toPx() else 1.dp.toPx()
                    )
                }
                
                currentTime += minorStep
            }
        }
    }
}

/**
 * Индикатор текущей позиции воспроизведения
 */
@Composable
private fun Playhead(
    position: Float,
    modifier: Modifier = Modifier,
    onDrag: (Float) -> Unit = {}
) {
    var isDragging by remember { mutableStateOf(false) }
    
    Box(
        modifier = modifier
            .width(2.dp)
            .background(MaterialTheme.colorScheme.error)
    ) {
        // Круглый маркер сверху для удобного перетаскивания
        Box(
            modifier = Modifier
                .size(20.dp)
                .offset(x = (-9).dp, y = (-10).dp)
                .align(Alignment.TopCenter)
                .clip(CircleShape)
                .background(MaterialTheme.colorScheme.error)
                .border(
                    width = 2.dp,
                    color = Color.White,
                    shape = CircleShape
                )
                .pointerInput(Unit) {
                    detectDragGestures(
                        onDragStart = { isDragging = true },
                        onDragEnd = { isDragging = false },
                        onDrag = { _, dragAmount ->
                            onDrag(dragAmount.x)
                        }
                    )
                }
        ) {
            // Центральная точка
            Box(
                modifier = Modifier
                    .size(6.dp)
                    .align(Alignment.Center)
                    .clip(CircleShape)
                    .background(Color.White)
            )
        }
    }
}

/**
 * Вычисление позиции playhead на таймлайне
 */
private fun calculatePlayheadPosition(
    segments: List<VideoSegment>,
    currentPosition: Float,
    zoomLevel: Float
): Float {
    return currentPosition * PIXELS_PER_SECOND * zoomLevel + 16 // +16 для padding
}

/**
 * Общий Shape для треугольника
 */
private val GenericShape = { builder: androidx.compose.ui.graphics.Path.(
    size: androidx.compose.ui.geometry.Size,
    layoutDirection: androidx.compose.ui.unit.LayoutDirection
) -> Unit ->
    androidx.compose.foundation.shape.GenericShape(builder)
}

/**
 * Данные о сегменте для обработки жестов
 */
private data class SegmentInfo(
    val segment: VideoSegment,
    val index: Int,
    val offset: Float,
    val width: Float,
    val isSelected: Boolean,
    val id: String
)

/**
 * Поиск сегмента по позиции касания
 */
private fun findSegmentAtPosition(
    position: Offset,
    segments: List<VideoSegment>,
    density: androidx.compose.ui.unit.Density,
    zoomLevel: Float,
    totalDuration: Float,
    timelineWidthDp: androidx.compose.ui.unit.Dp,
    selectedSegmentId: String?
): SegmentInfo? {
    var currentOffset = with(density) { 16.dp.toPx() } // Начальный padding
    
    segments.forEachIndexed { index, segment ->
        val segmentWidth = with(density) {
            (segment.duration * PIXELS_PER_SECOND * zoomLevel).dp.toPx()
        }
        
        if (position.x >= currentOffset && position.x <= currentOffset + segmentWidth) {
            return SegmentInfo(
                segment = segment,
                index = index,
                offset = currentOffset,
                width = segmentWidth,
                isSelected = segment.id == selectedSegmentId,
                id = segment.id
            )
        }
        
        currentOffset += segmentWidth + with(density) { 2.dp.toPx() } // Gap между сегментами
    }
    
    return null
}